buildscript {
    repositories {
        mavenLocal()
        mavenCentral() // maven { url 'http://jcenter.bintray.com' }
    }
    apply from: file('gradle/buildscript.gradle'), to: buildscript
}

plugins {
    id 'org.unbroken-dome.test-sets' version '1.2.0'
}

allprojects {
    repositories {
        mavenLocal()
        maven { url 'http://10.10.20.53:8081/nexus/repository/maven-public/' }
    }
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'java-library-distribution'

ext.verCommons = '0.1.2'
ext.verGuava = '18.0'
ext.verGuavaTEST = '14.0.1'
ext.verHadoopTEST = '2.5.1'
ext.verLog4j = '2.5'
ext.verMockito = '1.10.19'
ext.verPool = '2.3'
ext.verQuasar  = '0.6.2'
ext.verSlf4j = '1.7.21'
ext.verTestNG  = '6.8.21'

ext.classifierQuasar = ':jdk8'

testSets {
    testUnit { dirName = 'test/unit' }
    testIntegration { dirName = 'test/integration' }
}

configurations {
    guava
    provided
    provided {
        extendsFrom(compile)
    }
    testIntConf
    testIntConf {
        extendsFrom(provided)
        resolutionStrategy {
            force "com.google.guava:guava:${verGuavaTEST}"
            forcedModules = ["com.google.guava:guava:${verGuavaTEST}"]
        }
    }
}

sourceSets {
    main.compileClasspath += configurations.provided
    testUnit.compileClasspath += configurations.provided
    testUnit.runtimeClasspath += configurations.provided
    testIntegration.compileClasspath += configurations.testIntConf
    testIntegration.runtimeClasspath += configurations.testIntConf
}

apply from: file('gradle/convention.gradle')
apply from: file('gradle/check.gradle')
apply from: file('gradle/license.gradle')
apply from: file('gradle/maven.gradle')

if (project.hasProperty('env') && project.getProperty('env') == 'mapr') {
    repositories {
        mavenCentral()
        maven {
            url "http://repository.mapr.com/maven/"
        }
    }
    ext.verHBase = '0.98.12-mapr-1602-m7-5.1.0'
} else {
    ext.verHBase = '0.98.12-hadoop2'
}

group = 'com.liaison'
def artifact = "${rootProject.name}"
version = '0.1.7'
def packaging = 'jar'
def classifier = "${verHBase}"

ext.libraryName = "${rootProject.name}"

jar {
    manifest {
        attributes 'Implementation-Title': 'HBase Client', 'Implementation-Version': version
    }
}

dependencies {
    guava group:'com.google.guava', name:'guava', version:"${verGuava}"
    /*
    compile "org.slf4j:slf4j-api:${verSlf4j}"
    compile "org.apache.logging.log4j:log4j-slf4j-impl:${verLog4j}"
    compile "org.apache.logging.log4j:log4j-core:${verLog4j}"
    */
    compile "com.liaison:dm-lib-commons:${verCommons}"
    compile "co.paralleluniverse:quasar-core:${verQuasar}${classifierQuasar}"
    compile "org.apache.hbase:hbase-client:${verHBase}"
    compile "org.apache.hbase:hbase-common:${verHBase}"
    compile "org.apache.commons:commons-pool2:${verPool}"
    compile "org.testng:testng:${verTestNG}"
    testCompile "org.mockito:mockito-all:${verMockito}"
    testIntegrationCompile group:'com.google.guava', name:'guava', version:"${verGuavaTEST}"
    testIntegrationCompile group:'org.apache.hadoop', name:'hadoop-common', version:"${verHadoopTEST}", classifier: 'tests'
    testIntegrationCompile group:'org.apache.hbase', name:'hbase-server', version:"${verHBase}"
    testIntegrationCompile group:'org.apache.hbase', name:'hbase-server', version:"${verHBase}", classifier: 'tests'
    testIntegrationCompile group:'org.apache.hbase', name:'hbase-hadoop-compat', version:"${verHBase}"
    testIntegrationCompile group:'org.apache.hbase', name:'hbase-hadoop-compat', version:"${verHBase}", classifier: 'tests'
    testIntegrationCompile group:'org.apache.hbase', name:'hbase-hadoop2-compat', version:"${verHBase}"
    testIntegrationCompile group:'org.apache.hbase', name:'hbase-hadoop2-compat', version:"${verHBase}", classifier: 'tests'
    testIntegrationCompile group:'org.apache.hadoop', name:'hadoop-hdfs', version:"${verHadoopTEST}"
    testIntegrationCompile group:'org.apache.hadoop', name:'hadoop-hdfs', version:"${verHadoopTEST}", classifier: 'tests'
}

task fatJar(type: Jar) {
    baseName = project.name + '-all'
    from {
        configurations.compile.collect {
            logger.info "Including compile dependency in fat JAR: ${it}"
            it.isDirectory() ? it : zipTree(it)
        }
    }
    with jar
}

task copyToLib( type: Copy ) {
    into "$buildDir/libs/lib"
    from configurations.runtime
}

testUnit {
    useTestNG()
    logger.info "@@@ Classpath (UNIT testing): ${classpath.getFiles().collect({it.toString()}).inject('\n') {acc, next -> acc + next + '\n'}}"
    logger.info "@@@ SystemProps (UNIT testing): ${System.getProperties().collect({it.toString()}).inject('\n') {acc, next -> acc + next + '\n'}}"
}

testIntegration {
    classpath = classpath.minus(configurations.guava);
    useTestNG()
    systemProperty "java.net.preferIPv4Stack", "true"
    logger.info "@@@ Classpath (INTEGRATION testing): ${classpath.getFiles().collect({it.toString()}).inject('\n') {acc, next -> acc + next + '\n'}}"
    logger.info "@@@ SysProps (INTEGRATION testing): ${System.getProperties().collect({it.toString()}).inject('\n') {acc, next -> acc + next + '\n'}}"
}

test.dependsOn testUnit

distributions {
    main {
        baseName = "${libraryName}"
    }
}

uploadArchives {
    repositories {
       flatDir {
           dirs 'repos'
       }
    }
}

task createPom  {
    pom {
        project {
            artifactId artifact
            version version
            inceptionYear '2015'
            licenses {
                license {
                    name 'Liaison Proprietary'
                    url 'http://www.liaison.com'
                    distribution 'repo'
                }
            }
        }
    }.withXml { root ->
        def propsNode
        def children = root.asNode().children()
        def versionIndex

        versionIndex = children.indexOf(children.find {it.name().localPart == 'properties'})
        if (versionIndex >= 0) {
            propsNode = children.elementAt(versionIndex);
        } else {
            versionIndex = children.indexOf(children.find {it.name().localPart == 'inceptionYear'})
            propsNode = new Node(null, 'properties')
            children.add(versionIndex + 1, propsNode)
        }
        propsNode.children().add(0, new Node(null, 'classifier', classifier))

        versionIndex = children.indexOf(children.find {it.name().localPart == 'version'})
        children.add(versionIndex + 1, new Node(null, 'packaging', packaging))
    }.writeTo("pom.xml")
}

if (project.hasProperty('mainClass')) {
    task execute(type: JavaExec) {
        main = mainClass
        classpath = sourceSets.main.runtimeClasspath
        standardInput = System.in
    }
}

eclipse.classpath.plusConfigurations += configurations.provided
plugins.withType(IdeaPlugin) {
    idea {
        module {
            scopes.PROVIDED.plus += [configurations.provided]
            scopes.TEST.plus += [configurations.testIntegrationCompile]
        }
    }
}
